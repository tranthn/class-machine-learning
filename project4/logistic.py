#!/usr/bin/env python3
import sys
import numpy as np
import pandas as pd
import math

## gradient descent pseudocode
# initialize weights by assigning random values in [-0.01, 0.01]
#   - d = array size, # features
# repeat
#   - from 0...d, set delta weights (weight changes) to all 0's
#   - from 1...N 
#       - set output o of model to 0 as well
#       - inner loop: j = 0...d
#           - set output of model to o = o + w_j * x_tj # go across all dimensions of vector to add up feature x weight
#       - y = sigmoid(o) # pass result through logistic function to predict class
#       - calculate gradient to determine new weight update, using (real value - y)
#   - apply weight update and go onto next iteration
# stop at convergence (which is?)

# logistic sigmoid function
#
# arguments
#   - x: array of floats
#
# returns
#   - returns array with exponential value applied over
def sigmoid(x):
    return (1 / 1 + np.exp(-x))

# gradient descent function
#
# arguments
#   - df: dataframe we're processing
#
# returns
#   - returns coefficients generated by sigmoid function
def gradient_descent(df = None):
    d = df.shape[1]
    n = df.shape[0]
    feats = df.columns

    weights = np.random.uniform(-.01, 0.01, d)

    convergence = 10 # pick random number for now to stop at outer loop

    for i in range(convergence):

        # default weights delta array, with 0's
        weights_delta = np.zeros(d)

        # default model output array, with 0's
        for t in range(1, n):
            output = np.zeros(d)

            # set output of model
            for j in range(d):
                output[j] = output[j] + weights[j] # not sure how x_tj factors here [todo]
            
            y = sigmoid(output)

            for j in range(d):

                # real value, idk [todo]
                rv = 1.0
                weights_delta[j] = weights_delta[j] + (rv - y[j]) # not sure how x_tj factors here [todo]

        for j in range(d):
            weird_N = 1 # bias? [todo]
            weights[j] = weights[j] + weird_N * weights[j]

    return weights